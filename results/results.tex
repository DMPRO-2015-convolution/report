\section{Results}

In this section we present TODO.

\subsection{Scalability}
What convolution kernel matrix sizes can we handle, what image resolutions and depths... TODO: Add more text.

\subsection{Performance}
Performance was the main focus of our project.

TODO: Add more info on achieved throughput given image format, convolution kernel matrix size...

\subsubsection{EBI Throughput} \label{subsec:EbiThroughput}
During the project, the throughput over EBI between a EFM MCU and a Spartan-6 FPGA was tested by sending a sequence of increasing number which were verified on the FPGA.
A set-up time of 1 cycle was required in addition to the mandatory cycle always introduced by the MCU EBI controller for data to be transferred correctly.

Since the MCU is running with a clock speed of 48MHz, this resulted in a maximum throughput of $\unit[16]{bits} \cdot \unit[48]{MHz} / 2 = \unit[384]{Mbps}$.
From Table \ref{tab:BitRates}, we can conclude this is sufficient to accommodate all options listed except the most data intensive.

During the testing, a default FIFO queue implementation from Xilinx was used to cross the clock domain.
As EBI is asynchronous and therefore does not provide a clock, the last value sent was not received on the FPGA.
As a workaround, a final \textit{don't care} value was sent over the bus to push the final data value through the FIFO at the FPGA.

\subsubsection{SRAM Throughput} \label{subsec:SramThroughput}
During SRAM testing, several clock rates were tried to determine the speed achievable to SRAM.
After some binary search through the frequency spectrum, $\unit[49]{MHz}$ proved to be working.
This gives a throughput of $\unit[49]{MHz}\cdot\unit[16]{bit} = \unit[784]{Mbps}$ for reading.
During writing however, this number must be halved as a write requires two cycles (one for address set-up and one for writing), giving a throughput for writing of $\unit[392]{Mbps}$.

TODO: Make this fit in (taken from SRAM section in PCB Design chapter):

This is more than sufficient for our application as can be seen in Table \ref{tab:BitRates}, but we do expect this number to be significantly less due to latencies introduced on the FPGA and by the wires in between.

